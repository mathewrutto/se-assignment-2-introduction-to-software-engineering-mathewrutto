# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

Software Engineering is  the application of  principles of engineering tools and methods in the developing and maintaining  of software systems.

What is software engineering, and how does it differ from traditional programming?

software engineering is an engineering process that is mainly related to computers and programming and developing different kinds of applications through the use of information technology.
Software engineering differs from traditional programming in the following way:
Traditional programming focuses on writng code to work on specific scenarios or come up with specific functionalities  without consideringlife cycle  and engineering processes while software engineering entails a much more comprehensive approach that follow the stages of SDLC ie analysis, design, implementation, testing, maintenance


Software Development Life Cycle (SDLC):

This refers to a structured process that is used to design,develop and test  quality softawares




Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

1. Requirement Phase
 During this phase, the client states requirements, specifications, expectations, and any other special requirement related to the product or software. All these are gathered by the business manager or project manager or analyst of the service providing company.
The requirement includes how the product will be used and who will use the product to determine the load of operations. All information gathered from this phase is critical to developing the product as per the customer requirements.

2. Design Phase
The design phase includes a detailed analysis of new software according to the requirement phase. This is the high priority phase in the development life cycle of a system because the logical designing of the system is converted into physical designing. The output of the requirement phase is a collection of things that are required, and the design phase gives the way to accomplish these requirements. The decision of all required essential tools such as programming language like Java, .NET, PHP, a database like Oracle, MySQL, a combination of hardware and software to provide a platform on which software can run without any problem is taken in this phase.

3.Development Phase
After the successful completion of the requirement and design phase, the next step is to implement the design into the development of a software system. In this phase, work is divided into small units, and coding starts by the team of developers according to the design discussed in the previous phase and according to the requirements of the client discussed in requirement phase to produce the desired result.

4. Testing Phase
Testing is the last step of completing a software system.  Testing determines whether the software is actually giving the result as per the requirements addressed in the requirement phase or not. The Development team makes a test plan to start the test. This test plan includes all types of essential testing such as integration testing, unit testing, acceptance testing, and system testing. Non-functional testing is also done in this phase.
If there are any defects in the software or it is not working as per expectations, then the testing team gives information to the development team in detail about the issue. If it is a valid defect or worth to sort out, it will be fixed, and the development team replaces it with the new one, and it also needs to be verified.

5. Deployment
When software testing is completed with a satisfying result, and there are no remaining issues in the working of the software, it is delivered to the customer for their use.

6. Maintenance
The maintenance phase is the last and long-lasting phase of SDLC because it is the process which continues until the software's life cycle comes to an end. When a customer starts using software, then actual problems start to occur, and at that time there's a need to solve these problems. This phase also includes making changes in hardware and software to maintain its operational effectiveness like to improve its performance, enhance security features and according to customer's requirements with upcoming time. This process to take care of product time to time is called maintenance.

Agile vs. Waterfall Models:

Agile model follows the incremental approach, where each incremental part is developed through iteration after every timebox while Waterfall model follows a sequential design process.




Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?


	
a).	Progress -In the agile model, the measurement of progress is in terms of developed and delivered functionalities.	In the waterfall model, generally the measurement of success is in terms of completed and reviewed artifacts.
b).	Nature -	Agile model is flexible as there is a possibility of changing the requirements even after starting the development process.	On the other hand, the waterfall model is rigid as it does not allow to modify the requirements once the development process starts.
c)Customer interaction-In Agile model, there is a high customer interaction. It is because, after every iteration, an incremental version is deployed to the customer.	Customer interaction in waterfall model is very less. It is because, in a waterfall model, the product is delivered to the customer after overall development.
d)Team size-It has a small team size. As smaller is the team, the fewer people work on it so that they can move faster.	In the waterfall model, the team may consist more members.
e).	Suitability	Agile model is not a suitable model for small projects. The expenses of developing the small projects using agile is more than compared to other models.	Waterfall model works well in smaller size projects where requirements are easily understandable. But waterfall model is not suitable for developing the large projects.

Agile is best  Preferred in  Projects with dynamic requirements, where quick delivery and feedback from the clients are essential, such as startups .
Waterfall on the other hand is  Suitable for projects with clear and  unchanging requirements.



Requirements Engineering:

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:

Requirements engineering refers to the process of defining, documenting, and maintaining requirements in the engineering design process. Requirement engineering provides the appropriate mechanism to understand what the customer desires, analyzing the need, and assessing feasibility, negotiating a reasonable solution, specifying the solution clearly, validating the specifications and managing the requirements as they are transformed into a working system.

The process includes;
Feasibility Study
The objective behind the feasibility study is to create the reasons for developing the software that is acceptable to users, flexible to change and conformable to established standards.
Requirement Elicitation and Analysis
Software Requirement Specification
Software Requirement Validation
Software Requirement Management


Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?

Modularity in software design refers to the practice of partitioning a software system into realistic, manageable modules where  portion is managed independently with specific responsibilities
it improves:Isolating the  Changes
 Problems can be isolated thus easy to identify and fix issues.
simple testing




Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?

1: Unit Testing
Unit testing is the first level of software testing, which is used to test if software modules are satisfying the given requirement or not.

The first level of testing involves analyzing each unit or an individual component of the software application.

Unit testing is also the first level of functional testing. The primary purpose of executing unit testing is to validate unit components with their performance.

A unit component is an individual function or regulation of the application, or we can say that it is the smallest testable part of the software. The reason of performing the unit testing is to test the correctness of inaccessible code.

Unit testing will help the test engineer and developers in order to understand the base of code that makes them able to change defect causing code quickly. The developers implement the unit.


2: Integration Testing
The second level of software testing is the integration testing. The integration testing process comes after unit testing.

It is mainly used to test the data flow from one module or component to other modules.

3: System Testing
The third level of software testing is system testing, which is used to test the software's functional and non-functional requirements.

It is end-to-end testing where the testing environment is parallel to the production environment. In the third level of software testing, we will test the application as a whole system.

4: Acceptance Testing
The last and fourth level of software testing is acceptance testing, which is used to evaluate whether a specification or the requirements are met as per its delivery.

The software has passed through three testing levels (Unit Testing, Integration Testing, System Testing). Some minor errors can still be identified when the end-user uses the system in the actual scenario.





Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.

Version control systems are a category of software tools that helps in recording changes made to files by keeping a track of modifications done in the code. 
Benefits of the version control system:

1)Enhances the project development speed by providing efficient collaboration,
2)Leverages the productivity, expedites product delivery, and skills of the employees through better communication and assistance,
3)Reduce possibilities of errors and conflicts meanwhile project development through traceability to every small change,
4)Employees or contributors of the project can contribute from anywhere irrespective of the different geographical locations through this VCS,
5)For each different contributor to the project, a different working copy is maintained and not merged to the main file unless the working copy is validated. The most popular example is Git, Helix core, Microsoft TFS,
6)Helps in recovery in case of any disaster or contingent situation,
7)Informs us about Who, What, When, Why changes have been made.

Types of Version Control Systems
Local Version Control Systems
Centralized Version Control Systems
Distributed Version Control Systems

Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

1. Project Estimation
Project Size Estimation is the most significant parameter based on which all other estimations like cost, duration and effort are made.
Cost Estimation- Total expenses to develop the software product is estimated.
Time Estimation: The total time required to complete the project.
Effort Estimation: The effort needed to complete the project is estimated.
2. Scheduling
After the completion of the estimation of all the project parameters, scheduling for manpower and other resources is done.

3. Staffing
Team structure and staffing plans are made.

4. Risk Management
The project manager should identify the unanticipated risks that may occur during project development risk, analyze the damage that might cause these risks, and take a risk reduction plan to cope with these risks.

5.Lead the team: The project manager must be a good leader who makes a team of different members of various skills and can complete their individual tasks.
Motivate the team-member: One of the key roles of a software project manager is to encourage team members to work properly for the successful completion of the project.
6. Monitoring and reviewing- Project monitoring is a continuous process that lasts the whole time a product is being developed, during which the project manager compares actual progress and cost reports with anticipated reports as soon as possible. While most firms have a formal system in place to track progress, qualified project managers may still gain a good understanding of the project’s development by simply talking with participants.
7. Documenting project report- The project manager prepares the documentation of the project for future purposes. The reports contain detailed features of the product and various techniques. These reports help to maintain and enhance the quality of the project in the future.
8. Reporting- Reporting project status to the customer and his or her organization is the responsibility of the project manager. Additionally, they could be required to prepare brief, well-organized pieces that summarize key details from in-depth studies.  

Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?

Software Maintenance
Software maintenance is a part of the Software Development Life Cycle. Its primary goal is to modify and update software application after delivery to correct errors and to improve performance. Software is a model of the real world. When the real world changes, the software require alteration wherever possible.

Software Maintenance is an inclusive activity that includes error corrections, enhancement of capabilities, deletion of obsolete capabilities, and optimization.
Software Maintenance is needed for
Correct errors
Change in user requirement with time
Changing hardware/software requirements
To improve system efficiency
To optimize the code to run faster
To modify the components
To reduce any unwanted side effects

1. Corrective Maintenance
Corrective maintenance aims to correct any remaining errors regardless of where they may cause specifications, design, coding, testing, and documentation, etc.

2. Adaptive Maintenance
It contains modifying the software to match changes in the ever-changing environment.

3. Preventive Maintenance
It is the process by which we prevent our system from being obsolete. It involves the concept of reengineering & reverse engineering in which an old system with old technology is re-engineered using new technology. This maintenance prevents the system from dying out.

4. Perfective Maintenance
It defines improving processing efficiency or performance or restricting the software to enhance changeability. This may contain enhancement of existing system functionality, improvement in computational efficiency, etc.

Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

1. Unethical data collection
With the shift to digital marketing, companies are exponentially valuing user data. It’s an important source to use in development. However, it’s easy to get carried away in the act of acquiring it. Customers have to be fully aware of what information they’re sharing and how it’s going to be used.

Software developers face a difficult choice regarding personal data. They have two options: develop systems that possibly abuse user data or voice concerns despite going against the project’s objectives.

The best-case scenario is you should be free to voice worries about personal data ownership. If the use case violates privacy, legal, or ethical standards, the organization should investigate further and determine this on its own.

2. Algorithmic bias
Computers cannot understand morality as a concept. When it is not thoroughly checked, its systems can unintentionally show bias. For instance, when it was discovered that Google’s image processing engine couldn’t adequately reflect black and brown skin tones in images, the company came under fire for allegedly fostering systematic racism.

Software developers must deliberate potential biases in developing their products. By studying social norms and analyzing their current data, they can prevent wrong assumptions in the collection and use of information.

On the client’s end, they can prevent these mishaps by fostering a culture that encourages employees to speak up if they think a software feature is inappropriate. Being critical of the product helps address algorithmic prejudice.

3. Weak security
The software industry is prone to security issues. Developers need further education to learn and implement proper security practices. However, these kinds of training are often limited to cybersecurity-specific seminars.

Software experts have to take the initiative in learning security protocols. Fortunately, there are now plenty of development resources to strengthen one’s skills and knowledge about cybersecurity. As a software developer, it is your duty to implement and update your project with standardized security.

Depending on the type of website or application you’re developing, there are now protection guidelines you can refer to. For example, if you’re developing a health application, you can refer to the Payment Card Industry Data Security Standard (PCI DSS) and the Health Insurance Portability and Accountability Act (HIPPA).

4. Wrong Priorities
A lot of software engineering teams devote too much time to creating new features and improving the functionality of their products. However, they typically make the mistake of neglecting to customize and improve the existing functions. Unfortunately, in these situations, ethics frequently take a backseat. This may result in some ethical issues in software development.


ways of adhering

1. Be proactive
While you work honestly when writing code, there’s no telling where it can lead to. The client and your team can easily veer away from the original purpose of your project. Throughout the process of development, think of the potential threats and misconduct that can happen. As a software engineer, you must assess the current technology you’re developing and take proactive measures to address any potential abuse and other ethical issues in software development.

2. Be honest
Falsely advertising features or exaggerating the performance quality is unethical. Be straightforward and truthful while describing your goods. Inform the audience if the vision changes. Inform stakeholders as soon as there are updates or modifications to the software. To ensure that the product will be utilized as intended, create policies with the help of other teams inside your organization.

3. Be accountable
You should strive to improve the integrity and reputation of the profession as a software engineer. For instance, you should avoid making false claims regarding your application that could be deceptive or misleading. Make sure you keep your employer, clients, customers, and other stakeholders in the loop by reporting software issues and other potential ethical issues in software development.

4. Be a responsible citizen 
Software developers have this opportunity to build a product that will either benefit users or hurt them. Prioritize your responsibilities as a good citizen over your reputation as an expert. Only work on projects that you believe are secure, comply with specifications, and can withstand mandatory testing. By offering your expert technical services to worthy causes, you act responsibly as a citizen.